#!/usr/bin/env python3
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Îã§Ïö¥Î°úÎìú Ïä§ÌÅ¨Î¶ΩÌä∏
"""
import subprocess
import mysql.connector
from mysql.connector import Error
import pandas as pd
import time
import signal
import os
from datetime import datetime

class FixDuplicatesAndDownload:
    def __init__(self):
        self.ssh_process = None
        self.connection = None
        self.cursor = None
        self.output_path = '/Users/youz2me/Xcode/Livith-Data/output/cleaned_data'
        
        # Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        os.makedirs(self.output_path, exist_ok=True)

    def create_ssh_tunnel(self):
        """SSH ÌÑ∞ÎÑê ÏÉùÏÑ±"""
        try:
            print("üîß SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ï§ë...")
            
            ssh_command = [
                'ssh',
                '-i', '/Users/youz2me/Downloads/livith-key.pem',
                '-L', '3307:livithdb.c142i2022qs5.ap-northeast-2.rds.amazonaws.com:3306',
                '-N',
                '-o', 'StrictHostKeyChecking=no',
                'ubuntu@43.203.48.65'
            ]
            
            self.ssh_process = subprocess.Popen(
                ssh_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                preexec_fn=os.setsid
            )
            
            time.sleep(3)
            
            if self.ssh_process.poll() is None:
                print("‚úÖ SSH ÌÑ∞ÎÑê ÏÉùÏÑ± ÏôÑÎ£å!")
                return True
            else:
                return False
                
        except Exception as e:
            print(f"‚ùå SSH ÌÑ∞ÎÑê Ïò§Î•ò: {e}")
            return False

    def connect_mysql(self):
        """MySQL Ïó∞Í≤∞"""
        try:
            print("üîå MySQL Ïó∞Í≤∞ Ï§ë...")
            
            config = {
                'host': '127.0.0.1',
                'port': 3307,
                'user': 'root',
                'password': 'livith0407',
                'database': 'livith_v3',
                'charset': 'utf8mb4',
                'use_unicode': True
            }
            
            self.connection = mysql.connector.connect(**config)
            self.cursor = self.connection.cursor()
            
            print("‚úÖ MySQL Ïó∞Í≤∞ ÏÑ±Í≥µ!")
            return True
            
        except Error as e:
            print(f"‚ùå MySQL Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            return False

    def check_duplicates(self, table_name, unique_columns):
        """ÌÖåÏù¥Î∏îÏùò Ï§ëÎ≥µ ÌôïÏù∏"""
        try:
            print(f"\nüîç {table_name} ÌÖåÏù¥Î∏î Ï§ëÎ≥µ ÌôïÏù∏...")
            
            # Ï§ëÎ≥µ Î†àÏΩîÎìú Ï∞æÍ∏∞
            columns_str = ', '.join(unique_columns)
            having_clause = ' AND '.join([f'COUNT(DISTINCT {col}) = 1' for col in unique_columns])
            
            query = f"""
                SELECT {columns_str}, COUNT(*) as cnt
                FROM {table_name}
                GROUP BY {columns_str}
                HAVING COUNT(*) > 1
                ORDER BY cnt DESC
                LIMIT 10
            """
            
            self.cursor.execute(query)
            duplicates = self.cursor.fetchall()
            
            if duplicates:
                print(f"  ‚ö†Ô∏è Ï§ëÎ≥µ Î∞úÍ≤¨! (ÏÉÅÏúÑ 10Í∞ú)")
                for dup in duplicates:
                    print(f"    ‚Ä¢ {dup}")
                return True
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                return False
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ ÌôïÏù∏ Ïã§Ìå®: {e}")
            return False

    def remove_duplicates_artists(self):
        """artists ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞"""
        try:
            print("\nüßπ artists ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞ Ï§ë...")
            
            # Ï§ëÎ≥µÎêú artist Ï∞æÍ∏∞
            self.cursor.execute("""
                SELECT artist, COUNT(*) as cnt
                FROM artists
                GROUP BY artist
                HAVING COUNT(*) > 1
            """)
            duplicate_artists = self.cursor.fetchall()
            
            if duplicate_artists:
                print(f"  ‚Ä¢ Ï§ëÎ≥µÎêú ÏïÑÌã∞Ïä§Ìä∏: {len(duplicate_artists)}Í∞ú")
                
                for artist, count in duplicate_artists:
                    # Í∞ÄÏû• ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
                    self.cursor.execute("""
                        DELETE FROM artists 
                        WHERE artist = %s 
                        AND id NOT IN (
                            SELECT * FROM (
                                SELECT id FROM artists 
                                WHERE artist = %s 
                                ORDER BY updated_at DESC, id DESC 
                                LIMIT 1
                            ) as temp
                        )
                    """, (artist, artist))
                
                self.connection.commit()
                print(f"  ‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å")
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ Ï†úÍ±∞ Ïã§Ìå®: {e}")
            self.connection.rollback()

    def remove_duplicates_songs(self):
        """songs ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞"""
        try:
            print("\nüßπ songs ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞ Ï§ë...")
            
            # Ï§ëÎ≥µÎêú song Ï∞æÍ∏∞ (title + artist Ï°∞Ìï©)
            self.cursor.execute("""
                SELECT title, artist, COUNT(*) as cnt
                FROM songs
                GROUP BY title, artist
                HAVING COUNT(*) > 1
            """)
            duplicate_songs = self.cursor.fetchall()
            
            if duplicate_songs:
                print(f"  ‚Ä¢ Ï§ëÎ≥µÎêú ÎÖ∏Îûò: {len(duplicate_songs)}Í∞ú")
                
                for title, artist, count in duplicate_songs:
                    # Í∞ÄÏû• ÏµúÍ∑º Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
                    self.cursor.execute("""
                        DELETE FROM songs 
                        WHERE title = %s AND artist = %s
                        AND id NOT IN (
                            SELECT * FROM (
                                SELECT id FROM songs 
                                WHERE title = %s AND artist = %s
                                ORDER BY id DESC 
                                LIMIT 1
                            ) as temp
                        )
                    """, (title, artist, title, artist))
                
                self.connection.commit()
                print(f"  ‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å")
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ Ï†úÍ±∞ Ïã§Ìå®: {e}")
            self.connection.rollback()

    def remove_duplicates_setlists(self):
        """setlists ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞"""
        try:
            print("\nüßπ setlists ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞ Ï§ë...")
            
            # Ï§ëÎ≥µÎêú setlist Ï∞æÍ∏∞ (title + artist Ï°∞Ìï©)
            self.cursor.execute("""
                SELECT title, artist, COUNT(*) as cnt
                FROM setlists
                GROUP BY title, artist
                HAVING COUNT(*) > 1
            """)
            duplicate_setlists = self.cursor.fetchall()
            
            if duplicate_setlists:
                print(f"  ‚Ä¢ Ï§ëÎ≥µÎêú ÏÑ∏Ìä∏Î¶¨Ïä§Ìä∏: {len(duplicate_setlists)}Í∞ú")
                
                for title, artist, count in duplicate_setlists:
                    # Í∞ÄÏû• ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
                    self.cursor.execute("""
                        DELETE FROM setlists 
                        WHERE title = %s AND artist = %s
                        AND id NOT IN (
                            SELECT * FROM (
                                SELECT id FROM setlists 
                                WHERE title = %s AND artist = %s
                                ORDER BY updated_at DESC, id DESC 
                                LIMIT 1
                            ) as temp
                        )
                    """, (title, artist, title, artist))
                
                self.connection.commit()
                print(f"  ‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å")
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ Ï†úÍ±∞ Ïã§Ìå®: {e}")
            self.connection.rollback()

    def remove_duplicates_concert_info(self):
        """concert_info ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞"""
        try:
            print("\nüßπ concert_info ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞ Ï§ë...")
            
            # Ï§ëÎ≥µÎêú concert_info Ï∞æÍ∏∞ (concert_id + category Ï°∞Ìï©)
            self.cursor.execute("""
                SELECT concert_id, category, COUNT(*) as cnt
                FROM concert_info
                GROUP BY concert_id, category
                HAVING COUNT(*) > 1
            """)
            duplicate_info = self.cursor.fetchall()
            
            if duplicate_info:
                print(f"  ‚Ä¢ Ï§ëÎ≥µÎêú Ï†ïÎ≥¥: {len(duplicate_info)}Í∞ú")
                
                for concert_id, category, count in duplicate_info:
                    # Í∞ÄÏû• ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
                    self.cursor.execute("""
                        DELETE FROM concert_info 
                        WHERE concert_id = %s AND category = %s
                        AND id NOT IN (
                            SELECT * FROM (
                                SELECT id FROM concert_info 
                                WHERE concert_id = %s AND category = %s
                                ORDER BY updated_at DESC, id DESC 
                                LIMIT 1
                            ) as temp
                        )
                    """, (concert_id, category, concert_id, category))
                
                self.connection.commit()
                print(f"  ‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å")
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ Ï†úÍ±∞ Ïã§Ìå®: {e}")
            self.connection.rollback()

    def remove_duplicates_cultures(self):
        """cultures ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞"""
        try:
            print("\nüßπ cultures ÌÖåÏù¥Î∏î Ï§ëÎ≥µ Ï†úÍ±∞ Ï§ë...")
            
            # Ï§ëÎ≥µÎêú culture Ï∞æÍ∏∞ (concert_id + title Ï°∞Ìï©)
            self.cursor.execute("""
                SELECT concert_id, title, COUNT(*) as cnt
                FROM cultures
                GROUP BY concert_id, title
                HAVING COUNT(*) > 1
            """)
            duplicate_cultures = self.cursor.fetchall()
            
            if duplicate_cultures:
                print(f"  ‚Ä¢ Ï§ëÎ≥µÎêú Î¨∏Ìôî Ï†ïÎ≥¥: {len(duplicate_cultures)}Í∞ú")
                
                for concert_id, title, count in duplicate_cultures:
                    # Í∞ÄÏû• ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
                    self.cursor.execute("""
                        DELETE FROM cultures 
                        WHERE concert_id = %s AND title = %s
                        AND id NOT IN (
                            SELECT * FROM (
                                SELECT id FROM cultures 
                                WHERE concert_id = %s AND title = %s
                                ORDER BY updated_at DESC, id DESC 
                                LIMIT 1
                            ) as temp
                        )
                    """, (concert_id, title, concert_id, title))
                
                self.connection.commit()
                print(f"  ‚úÖ Ï§ëÎ≥µ Ï†úÍ±∞ ÏôÑÎ£å")
            else:
                print(f"  ‚úÖ Ï§ëÎ≥µ ÏóÜÏùå")
                
        except Exception as e:
            print(f"  ‚ùå Ï§ëÎ≥µ Ï†úÍ±∞ Ïã§Ìå®: {e}")
            self.connection.rollback()

    def download_table(self, table_name):
        """ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞Î•º CSVÎ°ú Îã§Ïö¥Î°úÎìú"""
        try:
            print(f"\nüì• {table_name} ÌÖåÏù¥Î∏î Îã§Ïö¥Î°úÎìú Ï§ë...")
            
            # Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            self.cursor.execute(f"SELECT * FROM {table_name}")
            rows = self.cursor.fetchall()
            
            # Ïª¨ÎüºÎ™Ö Í∞ÄÏ†∏Ïò§Í∏∞
            self.cursor.execute(f"DESCRIBE {table_name}")
            columns = [col[0] for col in self.cursor.fetchall()]
            
            # DataFrame ÏÉùÏÑ±
            df = pd.DataFrame(rows, columns=columns)
            
            # CSV Ï†ÄÏû•
            csv_path = f"{self.output_path}/{table_name}.csv"
            df.to_csv(csv_path, index=False, encoding='utf-8')
            
            print(f"  ‚úÖ {len(df)}Í∞ú Î†àÏΩîÎìú Ï†ÄÏû• ÏôÑÎ£å: {csv_path}")
            return True
            
        except Exception as e:
            print(f"  ‚ùå {table_name} Îã§Ïö¥Î°úÎìú Ïã§Ìå®: {e}")
            return False

    def close_connections(self):
        """Ïó∞Í≤∞ Ï¢ÖÎ£å"""
        try:
            if self.cursor:
                self.cursor.close()
            if self.connection:
                self.connection.close()
            if self.ssh_process:
                os.killpg(os.getpgid(self.ssh_process.pid), signal.SIGTERM)
            print("\nüîí Î™®Îì† Ïó∞Í≤∞ Ï¢ÖÎ£å ÏôÑÎ£å")
        except Exception as e:
            print(f"‚ö†Ô∏è Ïó∞Í≤∞ Ï¢ÖÎ£å Ï§ë Ïò§Î•ò: {e}")

    def run(self):
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏÑ∏Ïä§ Ïã§Ìñâ"""
        try:
            print("\n" + "="*60)
            print("üîß Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Îã§Ïö¥Î°úÎìú")
            print("="*60)
            
            # SSH ÌÑ∞ÎÑê ÏÉùÏÑ±
            if not self.create_ssh_tunnel():
                print("‚ùå SSH ÌÑ∞ÎÑê ÏÉùÏÑ± Ïã§Ìå®")
                return
            
            # MySQL Ïó∞Í≤∞
            if not self.connect_mysql():
                print("‚ùå MySQL Ïó∞Í≤∞ Ïã§Ìå®")
                return
            
            # 1. Ï§ëÎ≥µ Ï†úÍ±∞
            print("\n" + "="*40)
            print("üìä STEP 1: Ï§ëÎ≥µ Ï†úÍ±∞")
            print("="*40)
            
            self.remove_duplicates_artists()
            self.remove_duplicates_songs()
            self.remove_duplicates_setlists()
            self.remove_duplicates_concert_info()
            self.remove_duplicates_cultures()
            
            # 2. Ï§ëÎ≥µ ÌôïÏù∏
            print("\n" + "="*40)
            print("üìä STEP 2: Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ ÌôïÏù∏")
            print("="*40)
            
            self.check_duplicates('artists', ['artist'])
            self.check_duplicates('songs', ['title', 'artist'])
            self.check_duplicates('setlists', ['title', 'artist'])
            self.check_duplicates('concert_info', ['concert_id', 'category'])
            self.check_duplicates('cultures', ['concert_id', 'title'])
            
            # 3. Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú
            print("\n" + "="*40)
            print("üìä STEP 3: Ï†ïÎ¶¨Îêú Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú")
            print("="*40)
            
            tables_to_download = [
                'artists', 'concerts', 'songs', 'setlists', 
                'concert_info', 'cultures', 'md', 'schedule',
                'concert_genres', 'concert_setlists', 'setlist_songs',
                'home_sections', 'home_concert_sections',
                'search_sections', 'search_concert_sections'
            ]
            
            for table in tables_to_download:
                self.download_table(table)
            
            print("\n" + "="*60)
            print("‚úÖ Î™®Îì† ÏûëÏóÖ ÏôÑÎ£å!")
            print(f"üìÅ Îã§Ïö¥Î°úÎìú Í≤ΩÎ°ú: {self.output_path}")
            print("="*60)
            
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï§ëÎã®Îê®")
        except Exception as e:
            print(f"\n‚ùå Ïò§Î•ò Î∞úÏÉù: {e}")
        finally:
            self.close_connections()

if __name__ == "__main__":
    fixer = FixDuplicatesAndDownload()
    fixer.run()